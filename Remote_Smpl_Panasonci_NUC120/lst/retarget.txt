; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\retarget.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\retarget.d --cpu=Cortex-M0 --apcs=interwork -O0 -Otime -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\Nuvoton\NUC1xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\retarget.crf ..\..\..\Src\Driver\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=2

                  GetChar PROC
;;;95     /*---------------------------------------------------------------------------------------------------------*/
;;;96     char GetChar(void)
000000  e008              B        |L1.20|
                  |L1.2|
;;;97     {
;;;98     #if defined(DEBUG_ENABLE_SEMIHOST)
;;;99     # if defined ( __CC_ARM   )
;;;100        int nRet;
;;;101        while(SH_DoCommand(0x101, 0, &nRet) != 0)
;;;102        {
;;;103            if(nRet != 0)
;;;104            {
;;;105                    SH_DoCommand(0x07, 0, &nRet);
;;;106                    return (char)nRet;
;;;107            }
;;;108        }
;;;109    # else
;;;110        int nRet;
;;;111    	while(SH_DoCommand(0x7, 0, &nRet) != 0)  
;;;112    	{
;;;113    		if(nRet != 0)
;;;114    			return (char)nRet;
;;;115    	}
;;;116    # endif    
;;;117    #endif
;;;118    
;;;119    	if(DEBUG_PORT == 1)
;;;120    	{
;;;121    		while (1){
;;;122    			if(UART1->FSR.RX_EMPTY == 0 )
;;;123    			{
;;;124    				return (UART1->DATA);
;;;125    				
;;;126    		    }
;;;127    		}
;;;128    	}
;;;129    	else if(DEBUG_PORT == 0)
;;;130    	{
;;;131    		while (1){
;;;132    			if(UART0->FSR.RX_EMPTY == 0 )
000002  4805              LDR      r0,|L1.24|
000004  6980              LDR      r0,[r0,#0x18]
000006  0440              LSLS     r0,r0,#17
000008  0fc0              LSRS     r0,r0,#31
00000a  d103              BNE      |L1.20|
;;;133    			{
;;;134    				return (UART0->DATA);
00000c  4802              LDR      r0,|L1.24|
00000e  6800              LDR      r0,[r0,#0]
000010  b2c0              UXTB     r0,r0
;;;135    				
;;;136    		    }
;;;137    		}
;;;138    	}
;;;139    	else 
;;;140    	{
;;;141    		while (1){
;;;142    			if(UART2->FSR.RX_EMPTY == 0 )
;;;143    			{
;;;144    				return (UART2->DATA);
;;;145    				
;;;146    		    }
;;;147    		}
;;;148    	}
;;;149    
;;;150    }
000012  4770              BX       lr
                  |L1.20|
000014  e7f5              B        |L1.2|
;;;151    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x40050000

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;167    /*---------------------------------------------------------------------------------------------------------*/
;;;168    int IsDebugFifoEmpty(void)
000000  4802              LDR      r0,|L2.12|
;;;169    {
;;;170    #if(DEBUG_PORT == 0)
;;;171        return UART0->FSR.TE_FLAG;
000002  6980              LDR      r0,[r0,#0x18]
000004  00c0              LSLS     r0,r0,#3
000006  0fc0              LSRS     r0,r0,#31
;;;172    #elif(DEBUG_PORT == 1)
;;;173        return UART1->FSR.TE_FLAG;
;;;174    #else
;;;175        return UART2->FSR.TE_FLAG;
;;;176    #endif    
;;;177    }
000008  4770              BX       lr
;;;178    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40050000

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;63     
;;;64     void SendChar(int ch)
000000  b500              PUSH     {lr}
;;;65     {
000002  4603              MOV      r3,r0
;;;66     #if defined(DEBUG_ENABLE_SEMIHOST)
;;;67     	g_buf[g_buf_len++] = ch;
;;;68     	g_buf[g_buf_len] = '\0';
;;;69     	if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
;;;70     	{
;;;71     
;;;72     		/* Send the char */
;;;73     		if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
;;;74             {
;;;75                 g_buf_len = 0;
;;;76     			return;
;;;77             }
;;;78             else
;;;79             {
;;;80                 int i;
;;;81     
;;;82                 for(i=0;i<g_buf_len;i++)
;;;83                     SendChar_ToUART(g_buf[i]);
;;;84     		    g_buf_len = 0;
;;;85             }
;;;86     	}
;;;87     #else
;;;88         SendChar_ToUART(ch);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       SendChar_ToUART
;;;89     #endif
;;;90     }
00000a  bd00              POP      {pc}
;;;91     
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;40     
;;;41     void SendChar_ToUART(int ch)
000000  bf00              NOP      
                  |L4.2|
;;;42     {
;;;43     	if(DEBUG_PORT == 1)
;;;44     	{
;;;45     	    while(UART1->FSR.TX_FULL == 1);
;;;46     		UART1->DATA = ch;
;;;47     	    if(ch == '\n'){
;;;48     	        while(UART1->FSR.TX_FULL == 1);
;;;49     	        UART1->DATA = '\r';
;;;50     	    }
;;;51     	}
;;;52     	else if(DEBUG_PORT == 0)
;;;53     	{
;;;54     		while(UART0->FSR.TX_FULL == 1);
000002  4909              LDR      r1,|L4.40|
000004  6989              LDR      r1,[r1,#0x18]
000006  0209              LSLS     r1,r1,#8
000008  0fc9              LSRS     r1,r1,#31
00000a  d1fa              BNE      |L4.2|
;;;55     		UART0->DATA = ch;
00000c  4906              LDR      r1,|L4.40|
00000e  6008              STR      r0,[r1,#0]
;;;56     	    if(ch == '\n'){
000010  280a              CMP      r0,#0xa
000012  d108              BNE      |L4.38|
;;;57     	        while(UART0->FSR.TX_FULL == 1);
000014  bf00              NOP      
                  |L4.22|
000016  4904              LDR      r1,|L4.40|
000018  6989              LDR      r1,[r1,#0x18]
00001a  0209              LSLS     r1,r1,#8
00001c  0fc9              LSRS     r1,r1,#31
00001e  d1fa              BNE      |L4.22|
;;;58     	        UART0->DATA = '\r';
000020  210d              MOVS     r1,#0xd
000022  4a01              LDR      r2,|L4.40|
000024  6011              STR      r1,[r2,#0]
                  |L4.38|
;;;59     	    }
;;;60     	}
;;;61     }
000026  4770              BX       lr
;;;62     
                          ENDP

                  |L4.40|
                          DCD      0x40050000

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;181    /*---------------------------------------------------------------------------------------------------------*/
;;;182    void _ttywrch(int ch)
000000  b510              PUSH     {r4,lr}
;;;183    {
000002  4604              MOV      r4,r0
;;;184      SendChar(ch);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SendChar
;;;185      return;
;;;186    }
00000a  bd10              POP      {r4,pc}
;;;187    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;198    
;;;199    int ferror(FILE *f) {
000000  4601              MOV      r1,r0
;;;200      return EOF;
000002  2000              MOVS     r0,#0
000004  43c0              MVNS     r0,r0
;;;201    }
000006  4770              BX       lr
;;;202    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;193    
;;;194    int fgetc(FILE *f) {
000000  b500              PUSH     {lr}
000002  4601              MOV      r1,r0
;;;195      return (GetChar());
000004  f7fffffe          BL       GetChar
;;;196    }
000008  bd00              POP      {pc}
;;;197    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;187    
;;;188    int fputc(int ch, FILE *f)
000000  b530              PUSH     {r4,r5,lr}
;;;189    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;190      SendChar(ch);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SendChar
;;;191      return ch;
00000c  4620              MOV      r0,r4
;;;192    }
00000e  bd30              POP      {r4,r5,pc}
;;;193    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;154    /*---------------------------------------------------------------------------------------------------------*/
;;;155    int kbhit(void)
000000  4803              LDR      r0,|L9.16|
;;;156    {
;;;157    #if(DEBUG_PORT == 0)
;;;158        return !UART0->FSR.RX_EMPTY;
000002  6980              LDR      r0,[r0,#0x18]
000004  0440              LSLS     r0,r0,#17
000006  0fc0              LSRS     r0,r0,#31
000008  2101              MOVS     r1,#1
00000a  4048              EORS     r0,r0,r1
;;;159    #elif(DEBUG_PORT == 1)
;;;160        return !UART1->FSR.RX_EMPTY;
;;;161    #else
;;;162        return !UART2->FSR.RX_EMPTY;
;;;163    #endif    
;;;164    }
00000c  4770              BX       lr
;;;165    /*---------------------------------------------------------------------------------------------------------*/
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40050000

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  __stdin
                          DCD      0x00000000
