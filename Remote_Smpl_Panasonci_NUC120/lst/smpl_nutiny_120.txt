; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\smpl_nutiny_120.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\smpl_nutiny_120.d --cpu=Cortex-M0 --apcs=interwork -O0 -Otime -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\Nuvoton\NUC1xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\smpl_nutiny_120.crf Smpl_NUTINY_120.c]
                          THUMB

                          AREA ||i.InitSystem||, CODE, READONLY, ALIGN=2

                  InitSystem PROC
;;;90      */
;;;91     void InitSystem(void)
000000  b510              PUSH     {r4,lr}
;;;92     {
;;;93         uint32_t i;	
;;;94         UNLOCKREG();
000002  2059              MOVS     r0,#0x59
000004  4927              LDR      r1,|L1.164|
000006  6008              STR      r0,[r1,#0]
000008  2016              MOVS     r0,#0x16
00000a  6008              STR      r0,[r1,#0]
00000c  2088              MOVS     r0,#0x88
00000e  6008              STR      r0,[r1,#0]
;;;95         SYSCLK->PWRCON.XTL12M_EN = 1;   //设定12M外部晶振
000010  4825              LDR      r0,|L1.168|
000012  6800              LDR      r0,[r0,#0]
000014  0840              LSRS     r0,r0,#1
000016  0040              LSLS     r0,r0,#1
000018  1c40              ADDS     r0,r0,#1
00001a  4923              LDR      r1,|L1.168|
00001c  6008              STR      r0,[r1,#0]
;;;96         DrvSYS_Delay(5000);             //等待时钟就绪
00001e  4823              LDR      r0,|L1.172|
000020  f7fffffe          BL       DrvSYS_Delay
;;;97         DrvSYS_SelectPLLSource(E_SYS_EXTERNAL_12M);   //选择12MHz为PLL输入
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       DrvSYS_SelectPLLSource
;;;98         DrvSYS_Open(50000000);          //打开50MHz
00002a  4821              LDR      r0,|L1.176|
00002c  f7fffffe          BL       DrvSYS_Open
;;;99         LOCKREG();
000030  2000              MOVS     r0,#0
000032  491c              LDR      r1,|L1.164|
000034  6008              STR      r0,[r1,#0]
;;;100    		  
;;;101    
;;;102        /* 下面对GPIO管脚进行配置 */
;;;103        for(i=0;i<14;i++)
000036  2400              MOVS     r4,#0
000038  e009              B        |L1.78|
                  |L1.58|
;;;104        {
;;;105            DrvGPIO_Open(pupin[i].Port, pupin[i].Num, E_IO_OUTPUT);  //配置输入管脚
00003a  00e2              LSLS     r2,r4,#3
00003c  4b1d              LDR      r3,|L1.180|
00003e  18d2              ADDS     r2,r2,r3
000040  6851              LDR      r1,[r2,#4]
000042  00e2              LSLS     r2,r4,#3
000044  5c98              LDRB     r0,[r3,r2]
000046  2201              MOVS     r2,#1
000048  f7fffffe          BL       DrvGPIO_Open
00004c  1c64              ADDS     r4,r4,#1              ;103
                  |L1.78|
00004e  2c0e              CMP      r4,#0xe               ;103
000050  d3f3              BCC      |L1.58|
;;;106        }
;;;107        while(i<18)
000052  e009              B        |L1.104|
                  |L1.84|
;;;108        {
;;;109            DrvGPIO_Open(pupin[i].Port, pupin[i].Num, E_IO_OUTPUT); //配置输出管脚
000054  00e2              LSLS     r2,r4,#3
000056  4b17              LDR      r3,|L1.180|
000058  18d2              ADDS     r2,r2,r3
00005a  6851              LDR      r1,[r2,#4]
00005c  00e2              LSLS     r2,r4,#3
00005e  5c98              LDRB     r0,[r3,r2]
000060  2201              MOVS     r2,#1
000062  f7fffffe          BL       DrvGPIO_Open
;;;110            i++;
000066  1c64              ADDS     r4,r4,#1
                  |L1.104|
000068  2c12              CMP      r4,#0x12              ;107
00006a  d3f3              BCC      |L1.84|
;;;111        }	
;;;112    		
;;;113    		GPD_0 = 0;
00006c  2000              MOVS     r0,#0
00006e  4912              LDR      r1,|L1.184|
000070  6008              STR      r0,[r1,#0]
;;;114    		GPD_1 = 0;	 
000072  6048              STR      r0,[r1,#4]
;;;115    		GPD_2 = 0;
000074  6088              STR      r0,[r1,#8]
;;;116    		GPD_3 = 0;
000076  60c8              STR      r0,[r1,#0xc]
;;;117    		GPB_8 = 0;
000078  490f              LDR      r1,|L1.184|
00007a  3980              SUBS     r1,r1,#0x80
00007c  6208              STR      r0,[r1,#0x20]
;;;118    
;;;119    		GPC_0 = 0;	
00007e  490e              LDR      r1,|L1.184|
000080  3940              SUBS     r1,r1,#0x40
000082  6008              STR      r0,[r1,#0]
;;;120    		GPC_1 = 0;
000084  6048              STR      r0,[r1,#4]
;;;121    		GPC_2 = 0;
000086  6088              STR      r0,[r1,#8]
;;;122    		
;;;123    		GPC_8 = 1;
000088  2001              MOVS     r0,#1
00008a  6208              STR      r0,[r1,#0x20]
;;;124    		GPC_12 = 0;
00008c  2000              MOVS     r0,#0
00008e  6308              STR      r0,[r1,#0x30]
;;;125    		
;;;126        UART_Configuration();   //初始化UART
000090  f7fffffe          BL       UART_Configuration
;;;127        TIMER_Configuration();  //初始化TIMER    
000094  f7fffffe          BL       TIMER_Configuration
;;;128    		PWM_Configuration( PWM_Frequence , 25 );	
000098  2119              MOVS     r1,#0x19
00009a  207d              MOVS     r0,#0x7d
00009c  00c0              LSLS     r0,r0,#3
00009e  f7fffffe          BL       PWM_Configuration
;;;129    }
0000a2  bd10              POP      {r4,pc}
;;;130    
                          ENDP

                  |L1.164|
                          DCD      0x50000100
                  |L1.168|
                          DCD      0x50000200
                  |L1.172|
                          DCD      0x00001388
                  |L1.176|
                          DCD      0x02faf080
                  |L1.180|
                          DCD      pupin
                  |L1.184|
                          DCD      0x500042c0

                          AREA ||i.PWM_Configuration||, CODE, READONLY, ALIGN=1

                  PWM_Configuration PROC
;;;130    
;;;131    void PWM_Configuration(int frequence , int pulseratio)
000000  b57f              PUSH     {r0-r6,lr}
;;;132    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;133    S_DRVPWM_TIME_DATA_T sPt;
;;;134    /* PWM Timer property */ 
;;;135    sPt.u8Mode = DRVPWM_AUTO_RELOAD_MODE; /*自动重载模式*/ 
000006  2101              MOVS     r1,#1
000008  4668              MOV      r0,sp
00000a  7001              STRB     r1,[r0,#0]
;;;136    sPt.u32Frequency = frequence; // 100 /*PWM 频率 为100HZ即10000us为一周期*/ 
00000c  9401              STR      r4,[sp,#4]
;;;137    sPt.u8HighPulseRatio = pulseratio; //测试发现实际有误差矫正系数 //25; /* 高脉冲宽度时间所占周期的百分比: 25%*/ 
00000e  7045              STRB     r5,[r0,#1]
;;;138    sPt.i32Inverter = 0; /*反向关闭*/
000010  2000              MOVS     r0,#0
000012  9003              STR      r0,[sp,#0xc]
;;;139    /* Enable PWM clock */
;;;140    DrvPWM_Open(); //打开 PWM 时钟并且复位PWM
000014  f7fffffe          BL       DrvPWM_Open
;;;141    /* Select PWM engine clock */
;;;142    //DrvPWM_SelectClockSource(DRVPWM_TIMER0, DRVPWM_EXT_12M);//设置PWM 定时器0 为外部12 MHz crystal 时钟
;;;143    DrvSYS_SelectIPClockSource(E_SYS_PWM01_CLKSRC,0); //使用外设时注意必须设置该外设的时钟 设置PWM01的时钟源为外部12MHZ 
000018  2100              MOVS     r1,#0
00001a  2007              MOVS     r0,#7
00001c  f7fffffe          BL       DrvSYS_SelectIPClockSource
;;;144    /* Set PWM Timer0 Configuration */
;;;145    DrvPWM_SetTimerClk(DRVPWM_TIMER0, &sPt); //配置PWM 定时器0的一些参数 如配置频率/脉冲/模式/逆转功能
000020  4669              MOV      r1,sp
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       DrvPWM_SetTimerClk
;;;146    /* Enable Output for PWM Timer0 */
;;;147    DrvPWM_SetTimerIO(DRVPWM_TIMER0, 1); //使能或关闭PWM定时器0对应的IO口输出使能
000028  2101              MOVS     r1,#1
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       DrvPWM_SetTimerIO
;;;148    /* Set PWM pins */
;;;149    DrvGPIO_InitFunction(E_FUNC_PWM01); //指定多功能引脚 即 PA12，PA13为PWM0和PWM1
000030  2030              MOVS     r0,#0x30
000032  f7fffffe          BL       DrvGPIO_InitFunction
;;;150    /* Enable the PWM Timer 0 */
;;;151    DrvPWM_Enable(DRVPWM_TIMER0, 1); //使能/关闭PWM定时器0 
000036  2101              MOVS     r1,#1
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       DrvPWM_Enable
;;;152    }
00003e  bd7f              POP      {r0-r6,pc}
;;;153    
                          ENDP


                          AREA ||i.TIMER_Configuration||, CODE, READONLY, ALIGN=2

                  TIMER_Configuration PROC
;;;160     */
;;;161    void TIMER_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;162    {
;;;163        DrvTIMER_Init();  //初始化定时器
000002  f7fffffe          BL       DrvTIMER_Init
;;;164        DrvSYS_SelectIPClockSource(E_SYS_TMR0_CLKSRC,0x00);   //设定TIMER0的时钟源为外部12MHZ 
000006  2100              MOVS     r1,#0
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       DrvSYS_SelectIPClockSource
;;;165        DrvTIMER_Open(E_TMR0,TIMER0_FREQ,E_PERIODIC_MODE);  //设定定时器timer0的tick周期，并且启动定时器：TIMER0_FREQ，周期模式
00000e  2201              MOVS     r2,#1
000010  4908              LDR      r1,|L3.52|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       DrvTIMER_Open
;;;166        DrvTIMER_SetTimerEvent(E_TMR0, 1, (TIMER_CALLBACK)Timer0_Callback, 0);  //安装一个定时处理事件到 timer0通道
000018  2300              MOVS     r3,#0
00001a  4a07              LDR      r2,|L3.56|
00001c  2101              MOVS     r1,#1
00001e  4618              MOV      r0,r3
000020  f7fffffe          BL       DrvTIMER_SetTimerEvent
;;;167        DrvTIMER_EnableInt(E_TMR0);   //使能定时器中断 TIMER0->TCSR.IE = 1
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       DrvTIMER_EnableInt
;;;168        DrvTIMER_Start(E_TMR0); //定时器timer0开始计数 TIMER0->TCSR.CEN = 1;
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       DrvTIMER_Start
;;;169    }
000030  bd10              POP      {r4,pc}
;;;170    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      0x000009c4
                  |L3.56|
                          DCD      Timer0_Callback

                          AREA ||i.Timer0_Callback||, CODE, READONLY, ALIGN=2

                  Timer0_Callback PROC
;;;201     */
;;;202    void Timer0_Callback(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;203    {	
;;;204    	
;;;205    #ifdef _DEFAULT_MODE_
;;;206    	
;;;207    	uint8_t command[6]={0x0,0x0,0x0,0x0,0x0,0x0}; //0 0xff 1 命令区分停止和速度 2开关 或者速度 4 0xff
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  9001              STR      r0,[sp,#4]
;;;208    //	DrvUART_Write(UART_PORT1,buffer,4);	
;;;209    	GPD_0 = 0;   //485收到状态复位
000008  493c              LDR      r1,|L4.252|
00000a  6008              STR      r0,[r1,#0]
;;;210    
;;;211    	DrvUART_Read(UART_PORT1,command,4);	
00000c  2204              MOVS     r2,#4
00000e  4669              MOV      r1,sp
000010  0490              LSLS     r0,r2,#18
000012  f7fffffe          BL       DrvUART_Read
;;;212    	
;;;213    //	GPD_0 = 1;
;;;214    //	DrvUART_Write(UART_PORT1,command,4);
;;;215    	
;;;216    	if((command[0] == 0xff)&&(command[1] == 0)&&(command[2] == 1))         // ff000100   录像打开
000016  4668              MOV      r0,sp
000018  7800              LDRB     r0,[r0,#0]
00001a  28ff              CMP      r0,#0xff
00001c  d10b              BNE      |L4.54|
00001e  4668              MOV      r0,sp
000020  7840              LDRB     r0,[r0,#1]
000022  2800              CMP      r0,#0
000024  d107              BNE      |L4.54|
000026  4668              MOV      r0,sp
000028  7880              LDRB     r0,[r0,#2]
00002a  2801              CMP      r0,#1
00002c  d103              BNE      |L4.54|
;;;217      {
;;;218    		GPC_12 = 1;	//开关管为0 停止录像
00002e  4933              LDR      r1,|L4.252|
000030  3940              SUBS     r1,r1,#0x40
000032  6308              STR      r0,[r1,#0x30]
000034  e00e              B        |L4.84|
                  |L4.54|
;;;219    	}else if((command[0] == 0xff)&&(command[1] == 0)&&(command[2] == 0))   //ff000000     录像关闭
000036  4668              MOV      r0,sp
000038  7800              LDRB     r0,[r0,#0]
00003a  28ff              CMP      r0,#0xff
00003c  d10a              BNE      |L4.84|
00003e  4668              MOV      r0,sp
000040  7840              LDRB     r0,[r0,#1]
000042  2800              CMP      r0,#0
000044  d106              BNE      |L4.84|
000046  4668              MOV      r0,sp
000048  7880              LDRB     r0,[r0,#2]
00004a  2800              CMP      r0,#0
00004c  d102              BNE      |L4.84|
;;;220    	{  
;;;221    		GPC_12 = 0;	//开关管为1 开始录像
00004e  492b              LDR      r1,|L4.252|
000050  3940              SUBS     r1,r1,#0x40
000052  6308              STR      r0,[r1,#0x30]
                  |L4.84|
;;;222    	}  
;;;223    	
;;;224    	if((command[0] == 0xff)&&(command[1] == 1)&&(command[2] == 0))       //ff010030       缩放开始 
000054  4668              MOV      r0,sp
000056  7800              LDRB     r0,[r0,#0]
000058  28ff              CMP      r0,#0xff
00005a  d13a              BNE      |L4.210|
00005c  4668              MOV      r0,sp
00005e  7840              LDRB     r0,[r0,#1]
000060  2801              CMP      r0,#1
000062  d136              BNE      |L4.210|
000064  4668              MOV      r0,sp
000066  7880              LDRB     r0,[r0,#2]
000068  2800              CMP      r0,#0
00006a  d132              BNE      |L4.210|
;;;225    	{
;;;226    		PWM_Configuration( PWM_Frequence , command[3]*3/5 );   //第二次调节占空比则不准确了，使用比例系数实际只能0~~~~60变化		
00006c  4669              MOV      r1,sp
00006e  78c9              LDRB     r1,[r1,#3]
000070  004a              LSLS     r2,r1,#1
000072  1888              ADDS     r0,r1,r2
000074  2105              MOVS     r1,#5
000076  f7fffffe          BL       __aeabi_idivmod
00007a  4604              MOV      r4,r0
00007c  4621              MOV      r1,r4
00007e  207d              MOVS     r0,#0x7d
000080  00c0              LSLS     r0,r0,#3
000082  f7fffffe          BL       PWM_Configuration
;;;227    	 
;;;228    		// other mode 
;;;229    		if(command[3] <= 0x20)
000086  4669              MOV      r1,sp
000088  78c8              LDRB     r0,[r1,#3]
00008a  2820              CMP      r0,#0x20
00008c  dc07              BGT      |L4.158|
;;;230    		{
;;;231    			GPC_0 = 1;	//开关管为1 开始录像
00008e  2001              MOVS     r0,#1
000090  491a              LDR      r1,|L4.252|
000092  3940              SUBS     r1,r1,#0x40
000094  6008              STR      r0,[r1,#0]
;;;232    			GPC_1 = 0;
000096  2000              MOVS     r0,#0
000098  6048              STR      r0,[r1,#4]
;;;233    			GPC_2 = 0;
00009a  6088              STR      r0,[r1,#8]
00009c  e019              B        |L4.210|
                  |L4.158|
;;;234    		}
;;;235    		else if((command[3] < 0x30)&&((command[3] > 0x20)))
00009e  4668              MOV      r0,sp
0000a0  78c0              LDRB     r0,[r0,#3]
0000a2  2830              CMP      r0,#0x30
0000a4  da0a              BGE      |L4.188|
0000a6  4668              MOV      r0,sp
0000a8  78c0              LDRB     r0,[r0,#3]
0000aa  2820              CMP      r0,#0x20
0000ac  dd06              BLE      |L4.188|
;;;236    		{
;;;237    			GPC_0 = 0;	//开关管为1 开始录像
0000ae  2000              MOVS     r0,#0
0000b0  4912              LDR      r1,|L4.252|
0000b2  3940              SUBS     r1,r1,#0x40
0000b4  6008              STR      r0,[r1,#0]
;;;238    			GPC_1 = 0;
0000b6  6048              STR      r0,[r1,#4]
;;;239    			GPC_2 = 0;
0000b8  6088              STR      r0,[r1,#8]
0000ba  e00a              B        |L4.210|
                  |L4.188|
;;;240        }
;;;241    		else if(command[3] > 0x30)
0000bc  4668              MOV      r0,sp
0000be  78c0              LDRB     r0,[r0,#3]
0000c0  2830              CMP      r0,#0x30
0000c2  dd06              BLE      |L4.210|
;;;242    		{
;;;243    			GPC_0 = 0;	//开关管为1 开始录像
0000c4  2000              MOVS     r0,#0
0000c6  490d              LDR      r1,|L4.252|
0000c8  3940              SUBS     r1,r1,#0x40
0000ca  6008              STR      r0,[r1,#0]
;;;244    			GPC_1 = 0;
0000cc  6048              STR      r0,[r1,#4]
;;;245    			GPC_2 = 1;
0000ce  2001              MOVS     r0,#1
0000d0  6088              STR      r0,[r1,#8]
                  |L4.210|
;;;246    		}
;;;247      }
;;;248    
;;;249    	#if 0
;;;250    	//另一种工作模式定速定阻
;;;251    	if((command[0] == 0xff)&&(command[1] == 1)&&(command[2] == 2))
;;;252    	{
;;;253    		GPD_1 = 1;	//开关管为1 开始录像
;;;254    		GPD_2 = 0;
;;;255    		GPD_3 = 0;
;;;256    		
;;;257    	} 
;;;258    		if((command[0] == 0xff)&&(command[1] == 1)&&(command[2] == 3))
;;;259    	{
;;;260    		GPD_1 = 0;	//开关管为1 开始录像
;;;261    		GPD_2 = 1;
;;;262    		GPD_3 = 0;
;;;263    	} 
;;;264    		if((command[0] == 0xff)&&(command[1] == 1)&&(command[2] == 4))
;;;265    	{
;;;266    		GPD_1 = 0;	//开关管为1 开始录像
;;;267    		GPD_2 = 0;
;;;268    		GPD_3 = 1;
;;;269    	} 
;;;270    	#endif 
;;;271    #endif 
;;;272    	
;;;273    #ifdef _CHANGFENG_MODE_
;;;274      uint8_t command[7]={0x0,0x0,0x0,0x0,0x0,0x0,0x0}; //0 0xff 1 命令区分停止和速度 2开关 或者速度 4 0xff
;;;275    	DrvUART_Read(UART_PORT1,command,7);	
;;;276    	
;;;277    		// pelco-d 协议
;;;278    	if((command[0] == 0xff)&&(command[1] == 0x02)&&(command[2] == 0x00)) 
;;;279    	{
;;;280    		if((command[3] == 0x40)&&(command[4] == 0x00)&&(command[5] == 0x00)&&(command[6] == 0x42)) 
;;;281    		{
;;;282    				PWM_Configuration( PWM_Frequence , 15 );  
;;;283    				GPC_0 = 1;	//
;;;284    			  GPC_1 = 0;
;;;285    			  GPC_2 = 0;
;;;286    		}
;;;287    			
;;;288    		if((command[3] == 0x20)&&(command[4] == 0x00)&&(command[5] == 0x00)&&(command[6] == 0x22)) 
;;;289    		{
;;;290    				PWM_Configuration( PWM_Frequence , 50 );  
;;;291    		    GPC_0 = 0;	//
;;;292    			  GPC_1 = 0;
;;;293    			  GPC_2 = 0;
;;;294    		}
;;;295    			
;;;296    		if((command[3] == 0x00)&&(command[4] == 0x00)&&(command[5] == 0x00)&&(command[6] == 0x02)) 
;;;297    		{
;;;298    				PWM_Configuration( PWM_Frequence , 35 );  
;;;299    				GPC_0 = 0;	//
;;;300    			  GPC_1 = 0;
;;;301    			  GPC_2 = 1;
;;;302    		}
;;;303    	}		
;;;304    #endif 
;;;305    	
;;;306    #ifdef _NETWORK_MODE_
;;;307    	uint8_t command[6]={0x0,0x0,0x0,0x0,0x0,0x0}; //0 0xff 1 命令区分停止和速度 2开关 或者速度 4 0xff
;;;308    
;;;309    	GPD_0 = 0;   //485收到状态复位
;;;310    
;;;311    	DrvUART_Read(UART_PORT1,command,5);	
;;;312    
;;;313    	if((command[0] == 0xff)&&(command[4] == REMOTE_DEVICE_ID))  //comand 5bit is device ID number.
;;;314    	{	
;;;315    
;;;316    		
;;;317    		if((command[0] == 0xff)&&(command[1] == 0)&&(command[2] == 1))         // ff000100   录像打开
;;;318    		{
;;;319    			GPC_12 = 1;	//开关管为0 停止录像
;;;320    		}else if((command[0] == 0xff)&&(command[1] == 0)&&(command[2] == 0))   //ff000000     录像关闭
;;;321    		{  
;;;322    			GPC_12 = 0;	//开关管为1 开始录像
;;;323    		}else  
;;;324    		
;;;325    		if((command[0] == 0xff)&&(command[1] == 1)&&(command[2] == 0))       //ff010030       缩放开始 
;;;326    		{
;;;327    			PWM_Configuration( PWM_Frequence , command[3]*3/5 );   //第二次调节占空比则不准确了，使用比例系数实际只能0~~~~60变化		
;;;328    		}
;;;329    		
;;;330    		//另一种工作模式定速定阻
;;;331    		if((command[0] == 0xff)&&(command[1] == 1)&&(command[2] == 2))
;;;332    		{
;;;333    			GPD_1 = 1;	//开关管为1 开始录像
;;;334    			GPD_2 = 0;
;;;335    			GPD_3 = 0;
;;;336    			
;;;337    		} 
;;;338    			if((command[0] == 0xff)&&(command[1] == 1)&&(command[2] == 3))
;;;339    		{
;;;340    			GPD_1 = 0;	//开关管为1 开始录像
;;;341    			GPD_2 = 1;
;;;342    			GPD_3 = 0;
;;;343    		} 
;;;344    			if((command[0] == 0xff)&&(command[1] == 1)&&(command[2] == 4))
;;;345    		{
;;;346    			GPD_1 = 0;	//开关管为1 开始录像
;;;347    			GPD_2 = 0;
;;;348    			GPD_3 = 1;
;;;349    		} 
;;;350    		
;;;351    	}
;;;352    #endif 	
;;;353    
;;;354    		
;;;355    	GPC_8 = 0;
0000d2  2000              MOVS     r0,#0
0000d4  4909              LDR      r1,|L4.252|
0000d6  3940              SUBS     r1,r1,#0x40
0000d8  6208              STR      r0,[r1,#0x20]
;;;356    	delay_loop();
0000da  f7fffffe          BL       delay_loop
;;;357    	delay_loop();
0000de  f7fffffe          BL       delay_loop
;;;358    	delay_loop();
0000e2  f7fffffe          BL       delay_loop
;;;359    	delay_loop();
0000e6  f7fffffe          BL       delay_loop
;;;360    	delay_loop();
0000ea  f7fffffe          BL       delay_loop
;;;361    	delay_loop();
0000ee  f7fffffe          BL       delay_loop
;;;362    	GPC_8 = 1;  //LED闪烁1次 收到数据
0000f2  2001              MOVS     r0,#1
0000f4  4901              LDR      r1,|L4.252|
0000f6  3940              SUBS     r1,r1,#0x40
0000f8  6208              STR      r0,[r1,#0x20]
;;;363    		 
;;;364    }
0000fa  bd1c              POP      {r2-r4,pc}
;;;365    
                          ENDP

                  |L4.252|
                          DCD      0x500042c0

                          AREA ||i.UART_Configuration||, CODE, READONLY, ALIGN=1

                  UART_Configuration PROC
;;;176     */
;;;177    void UART_Configuration(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;178    {
;;;179        STR_UART_T param;
;;;180      
;;;181        /* Select UART Clock Source From 12MHz */
;;;182        DrvSYS_SelectIPClockSource(E_SYS_UART_CLKSRC, 0x00);  //使能UART时钟
000002  2100              MOVS     r1,#0
000004  2006              MOVS     r0,#6
000006  f7fffffe          BL       DrvSYS_SelectIPClockSource
;;;183    
;;;184        param.u32BaudRate = UART0_BAUD; //波特率
00000a  20e1              MOVS     r0,#0xe1
00000c  0240              LSLS     r0,r0,#9
00000e  9000              STR      r0,[sp,#0]
;;;185        param.u8cDataBits = DRVUART_DATABITS_8; //数据位
000010  2103              MOVS     r1,#3
000012  4668              MOV      r0,sp
000014  7101              STRB     r1,[r0,#4]
;;;186        param.u8cStopBits = DRVUART_STOPBITS_1; //停止位
000016  2100              MOVS     r1,#0
000018  7141              STRB     r1,[r0,#5]
;;;187        param.u8cParity = DRVUART_PARITY_NONE;  //校验位
00001a  7181              STRB     r1,[r0,#6]
;;;188        param.u8cRxTriggerLevel = DRVUART_FIFO_4BYTES;   //FIFO存储深度63字节
00001c  2101              MOVS     r1,#1
00001e  71c1              STRB     r1,[r0,#7]
;;;189        param.u8TimeOut = 0;  //FIFO超时设定
000020  2100              MOVS     r1,#0
000022  7201              STRB     r1,[r0,#8]
;;;190     
;;;191        DrvGPIO_InitFunction(E_FUNC_UART1);   //复用功能引脚设置
000024  202c              MOVS     r0,#0x2c
000026  f7fffffe          BL       DrvGPIO_InitFunction
;;;192        DrvUART_Open(UART_PORT1, &param);   //串口usart1开启、结构体整体赋值
00002a  4669              MOV      r1,sp
00002c  2001              MOVS     r0,#1
00002e  0500              LSLS     r0,r0,#20
000030  f7fffffe          BL       DrvUART_Open
;;;193    }
000034  bd0e              POP      {r1-r3,pc}
;;;194    
                          ENDP


                          AREA ||i.delay_loop||, CODE, READONLY, ALIGN=1

                  delay_loop PROC
;;;63     
;;;64     void delay_loop(void)
000000  2000              MOVS     r0,#0
;;;65      {
;;;66         uint32_t j;
;;;67      		for(j=0;j<60;j++);		
000002  e000              B        |L6.6|
                  |L6.4|
000004  1c40              ADDS     r0,r0,#1
                  |L6.6|
000006  283c              CMP      r0,#0x3c
000008  d3fc              BCC      |L6.4|
;;;68     
;;;69      }
00000a  4770              BX       lr
;;;70      
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;76      */
;;;77     int main(void)
000000  f7fffffe          BL       InitSystem
;;;78     { 
;;;79     	InitSystem();	
;;;80     	while(1);
000004  bf00              NOP      
                  |L7.6|
000006  e7fe              B        |L7.6|
;;;81     	
;;;82     }
;;;83     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  buffer
000000  11121314          DCB      0x11,0x12,0x13,0x14
                  pupin
000004  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x00000001
00000c  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x00000002
000014  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x00000003
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000005
000024  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000004
00002c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000003
000034  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000002
00003c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000001
000044  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
00004c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000000c
000054  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000000d
00005c  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000007
000064  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000006
00006c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000000f
000074  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000008
00007c  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x0000000c
000084  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000009
00008c  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x00000008

                  __ARM_use_no_argv EQU 0
